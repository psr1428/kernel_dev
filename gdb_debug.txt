target remote | qemu-system-x86_64 -hda ./boot.bin -S -gdb stdio

export PATH="$PREFIX/bin:$PATH"
export PATH="$PREFIX/bin:$PATH"
export PREFIX="$HOME/opt/cross"

remote debug :
qemu-system-x86_64 -drive format=raw,file=./build/os.bin -S -gdb tcp::1234 --nographic
gdb
target remote localhost:1234
add-symbol-file ./build/kernel_full.o 0x100000


target remote | qemu-system-i386 -hda ./build/os.bin -S -gdb stdio

#include "paging.h"
#include "kheap.h"
#include "stdbool.h"

static uint32_t *curr_dir;

void paging_load_dir(uint32_t* dir);

struct paging_chunk *paging_new(uint8_t flags)
{   
    int offset = 0;
    uint32_t *dir = kernel_zalloc(sizeof(uint32_t)*TOTAL_PAGE_TABLE_ENTRIES);
    for(int  i=0;  i< TOTAL_PAGE_TABLE_ENTRIES; i++)
    {
        uint32_t *entry = kernel_zalloc(sizeof(uint32_t)*TOTAL_PAGE_TABLE_ENTRIES);
        for(int j = 0; j < TOTAL_PAGE_TABLE_ENTRIES; j++)
        {
            entry[j] = (offset + (j *PAGE_SIZE))  | flags;
        }
        offset += (PAGE_SIZE * TOTAL_PAGE_TABLE_ENTRIES);
        dir[i] = (uint32_t) entry | flags | PAGING_IS_WRITABLE;
    }
    struct paging_chunk *chunk = kernel_zalloc(sizeof(struct paging_chunk));
    chunk->dir_entry = dir;
    return chunk;
}

uint32_t *paging_get_dir(struct paging_chunk *chunk)
{
    return chunk->dir_entry;
}

void paging_switch(uint32_t* dir)
{
    paging_load_dir(dir);
    curr_dir = dir;
}

bool paging_is_aligned(void *addr)
{
    return ((uint32_t)addr % PAGE_SIZE) == 0;
}

int paging_get_idx(void *virtual_addr,uint32_t *dir_idx,uint32_t *table_idx)
{
    if(!paging_is_aligned(virtual_addr))
    {
        return -EINVARG;
    }
    *dir_idx = ((uint32_t)virtual_addr / (PAGE_SIZE * TOTAL_PAGE_TABLE_ENTRIES));
    *table_idx = ((uint32_t)virtual_addr % ((PAGE_SIZE * TOTAL_PAGE_TABLE_ENTRIES)/PAGE_SIZE));
    return 0;
}

int paging_set(void *virtual_addr,uint32_t *dir,uint32_t val)
{
    uint32_t dir_idx = 0;
    uint32_t table_idx = 0;
    if(!paging_is_aligned(virtual_addr))
    {
        return -EINVARG;
    }
    int res = paging_get_idx(virtual_addr,&dir_idx,&table_idx);
    if ( res < 0)
    {
        return res;
    }
    uint32_t page_table_entry = dir[dir_idx];
    uint32_t *table_addr = (uint32_t*)(page_table_entry & 0xfffff000);
    table_addr[table_idx] = val;
    return 0;
}


#ifndef PAGING_H
#define PAGING_H

#include <stdint.h>
#include <stddef.h>

#define PAGING_CACHE_DISABLED  0b00010000
#define PAGING_WRITE_THROUGH   0b00001000
#define PAGING_ACCESS_FROM_ALL 0b00000100
#define PAGING_IS_WRITABLE     0b00000010
#define PAGING_IS_PRESENT      0b00000001

#define TOTAL_PAGE_TABLE_ENTRIES 1024
#define PAGE_SIZE                4096
/*4 gb paging chunk*/
struct paging_chunk
{
    uint32_t *dir_entry;
};
void enable_paging();
struct paging_chunk *paging_new(uint8_t flags);
void paging_switch(uint32_t *dir);
uint32_t *paging_get_dir(struct paging_chunk *chunk);
int paging_set(void *virtual_addr,uint32_t *dir,uint32_t val);
#endif